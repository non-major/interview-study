# 1. 이벤트 버블링에 대해 설명해 주세요.

한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작합니다. 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작하는 것을 이벤트 버블링이라고 합니다. 버블링을 중단하기 위해서 이벤트 객체의 메서드인 event.stopPropagation()를 사용합니다.
<br>

_예시_

```
<form onclick="alert('form')">FORM
  <div onclick="alert('div')">DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>
```

가장 안쪽의 `<p>`를 클릭하면 순서대로 다음과 같은 일이 벌어집니다.

1. `<p>`에 할당된 onclick 핸들러가 동작합니다.
2. 바깥의 `<div>`에 할당된 핸들러가 동작합니다.
3. 그 바깥의 `<form>`에 할당된 핸들러가 동작합니다.
4. document 객체를 만날 때까지, 각 요소에 할당된 onclick 핸들러가 동작합니다.

<br>

## 꼬리질문

- 이벤트 캡처링에 대해 설명해 주세요.
- event.target과 this(=event.currentTarget)의 차이점에 대해 설명해 주세요.
- [참고링크](https://ko.javascript.info/bubbling-and-capturing)
  <br><br>

# 2. 리액트 라이프 사이클에 대해 설명해 주세요.

\*\*클래스형 컴포넌트에서 사용하는 메서드들이므로 이런 것이 있다고만 알고 넘어가셔도 무방합니다.

<img src="https://velog.velcdn.com/images%2Fminbr0ther%2Fpost%2F7f8ed738-2f24-46bd-ab9f-2c7e7d7976e2%2FUntitled-3.png" width="60%"></img>
<br>[>> 참고](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

리액트의 모든 컴포넌트들은 생명 주기를 갖습니다. 이는 크게 마운트(생성) > 업데이트 > 언마운트(제거)의 세 단계로 구분합니다. 이때 함수형 컴포넌트는 useEffect를 사용, 클래스형 컴포넌트는 생명 주기 메서드를 사용하여 코드를 작성할 수 있습니다.
<br>

### **1. 마운트 시 호출되는 메서드**

- **constructor** <br>
  컴포넌트가 마운트되기 전에 호출됩니다. this.state에 객체를 할당하여 state를 초기화하고, 인스턴스에 이벤트 처리 메서드를 바인딩합니다.
  <br>
- **getDerivedStateFromProps** <br>
  컴포넌트가 최초 마운트될 때와 업데이트 될 때 호출됩니다. state를 갱신하기 위한 객체를 반환하거나, null을 반환하여 아무 것도 갱신하지 않을 수 있습니다. props가 변경되었을 때 state도 업데이트하는 용도로 사용합니다. (props가 변경되었을 때 부수 효과를 발생하거나 일부 데이터를 다시 계산하거나 일부 state를 변경하는 용도에는 다른 방식을 사용하는 것이 권장됩니다. [>> 참고](https://ko.reactjs.org/docs/react-component.html#static-getderivedstatefromprops))
  <br>
- **render** <br>
  컴포넌트를 렌더링합니다. 클래스 컴포넌트에서 반드시 구현되어야 하는 메서드입니다. render() 함수는 컴포넌트의 state를 변경하지 않고, 호출될 때마다 동일한 결과를 반환해야 하며, 브라우저와 직접적으로 상호작용하지 않아야 합니다.
  <br>
- **componentDidMount** <br>
  컴포넌트가 마운트된 직후 호출됩니다. 외부에서 데이터를 불러와야 할 때, 네트워크 요청을 보내기 적절한 위치입니다. 이 메서드에 데이터 구독을 설정한다면 componentWillUnmount()에서 구독 해제 작업을 해야합니다.
  <br><br>

### **2. 업데이트 시 호출되는 메서드**

- **getDerivedStateFromProps** <br>
  (위와 동일)
  <br>
- **shouldComponentUpdate** <br>
  props 또는 state가 변경되었을 때 컴포넌트의 리렌더링 여부를 결정합니다. 기본적으로 state 변경 시에 리렌더링 되도록 동작하므로, 특정 state가 변경되었을 때 false를 반환하는 것으로 리렌더링 작업을 건너뛰게 만들 수 있습니다. 이 메서드는 오직 성능 최적화만을 위한 것으로 렌더링을 방지하는 목적으로 사용할 경우 버그로 이어질 수 있습니다.
  <br>
- **render** <br>
  (위와 동일)
  <br>
- **getSnapshotBeforeUpdate** <br>
  컴포넌트가 마지막으로 렌더링된 결과가 DOM에 반영되기 전에 호출됩니다. 컴포넌트가 업데이트 되기 직전에 스크롤 위치 등과 같은 정보를 얻을 수 있습니다. 이 메서드가 반환하는 값은 componentDidUpdate에 세 번째 인자로 전달됩니다.
  <br>
- **componentDidUpdate** <br>
  컴포넌트가 업데이트가 된 직후에 호출됩니다. 최초 렌더링에서는 호출되지 않습니다. 이전과 현재의 props를 비교하여 네트워크 요청을 보내는 작업에 사용합니다. 이 메서드에서 setState()를 호출할 때 조건문으로 감싸지 않으면 무한 반복이 발생할 수 있습니다.
  <br><br>

### **3. 언마운트 시 호출되는 메서드**

- **componentWillUnmount** <br>
  컴포넌트가 DOM 상에서 제거될 때 호출됩니다. 타이머 제거, 네트워크 요청 취소, 데이터 구독 해제 등 모든 정리 작업을 수행합니다. 이제 컴포넌트가 다시 렌더링되지 않으므로 setState()를 호출하면 안 됩니다.

<br>

## 꼬리질문

- useEffect에 대해 설명해 주세요.
  <br><br>

# 3. SessionStorage, LocalStorage, Cookie에 대해 설명해 주세요.

- 쿠키는 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각입니다. 브라우저는 쿠키를 저장하고 동일한 서버에 재요청 시 쿠키를 함께 전송합니다. 이는 서버가 동일한 브라우저에서 들어온 요청인지 판단할 때 쓰입니다. 문자열만 저장할 수 있고, 하나의 쿠키에 4kb 크기까지 저장 가능합니다. 암호화 되지 않은 상태로 사용되기에 보안에 취약하고, 모든 요청마다 함께 전송되어 성능에 영향을 주는 특징이 있습니다.

- 로컬 스토리지와 세션 스토리지는 HTML5부터 추가된 기능으로 브라우저에 데이터를 key-value 쌍으로 저장하는 저장소입니다. 서버 요청 시에 데이터가 전송되지 않고, 객체 형태로 저장할 수 있으며, 5mb의 크기까지 저장 가능합니다. 로컬 스토리지는 도메인별로 생성되며, 도메인이 같다면 전역으로 공유할 수 있고, 브라우저를 닫아도 삭제되지 않습니다. 세션 스토리지는 도메인별로 생성되지만 현재 열려있는 브라우저 내에서만 유효하기 때문에 브라우저를 닫으면 데이터가 삭제됩니다.

<br>

## 꼬리질문

- indexedDB에 대해 설명해 주세요.
