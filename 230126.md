# 콜백 함수에 대해 설명해주세요.

콜백 함수는 다른 함수의 인자로 전달되는 함수인데, 이 함수는 어떤 작업을 완료하기 위해 인자로 전달 받은 함수 안에서 호출된다. 동기식 콜백 함수와 비동기식 콜백 함수로 분류할 수 있다.

```jsx
function greeting (name) {
	alert(`Hello, ${name}`);
}

function processUserInput(callback) {
	const name = propmt("Please enter your name);
	callback(name);
}

processUserInput(greeting);
```

위 예제는 동기식 콜백 예제로, 즉시 실행된다.

(호출한 함수가 return 되기 전에 콜백 함수가 호출됨)

콜백 함수는 비동기 연산에 자주 사용된다.

예를 들면, 비동기식 콜백 함수는 프로미스 연산이 완료되거나 거절된 이후 프로미스 끝에 연결된 then 함수 안에서 실행되는 함수들이다. 이 구조는 많은 모던 웹 API에서 사용되고 있고 fetch 함수가 그러한 예다.

* 비동기 콜백 함수는 입출력 연산이나 이벤트 핸들러에 자주 사용된다.

(호출한 함수가 return 이후에 콜백 함수가 호출됨)

콜백 함수를 중첩하여 사용하는 경우

콜백 함수 내부에 콜백 함수, 그 내부에 콜백함수 … → 이를 콜백 지옥이라 부른다.

가독성과 디버깅하기 어려울 수 있다.

또한 에러 핸들링 할 때, top 레벨에서만 처리해주는 대신, 각 레벨에서 처리해야 하는 경우도 존재하기 때문에 에러 처리에 힘들 수 있다.

참고
https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing

# 클래스형 컴포넌트와 함수형 컴포넌트를 비교해주세요.

리액트에서 리액트 컴포넌트를 작성하는 방법은 두 가지다.

하나는 함수를 사용하는 것이고 다른 하나는 클래스를 사용하는 것이다.

우선 문법에 차이가 있다.

**Rendering JSX**

함수형 컴포넌트는 함수인데 JSX를 리턴하는 형태다.

```jsx
import React from "react";

const FunctionalComponent = () => {
	return <p>Hello, world</p>;
};
```

클래스 컴포넌트는 React.Component를 extends한 JS 클래스로 render 메소드를 가지고 있다.

렌더할 JSX는 render 메소드 안에서 리턴해야 한다.

```jsx
import React, {Component} from 'react'

class ClassComponent extends Component {
	render() {
		return <p>Hello, world</p>;
	}
}
```

**Passing Props**

함수형 컴포넌트 안에서 함수 인자처럼 props를 전달한다.

```jsx
<FunctionalComponent name="dihoon">

const FunctionalComponent = (props) => {
	return <p>Hello, {props.name}</p>;
};
```

클래스 컴포넌트는 클래스라서 props 참조하려면 this 키워드를 사용해야 한다.

```jsx
<ClassComponent name="dihoon">

class ClassComponent extends React.Component {
	render () {
		const {name} = this.props;
		return <p>Hello, {name}</p>
	}
}
```

**Handling state**

상태 관리는 최근까지만 해도 클래스형 컴포넌트에서 할 수 있었지만 React 16.8부터, 개발자에게 상태 관리 가능한 함수형 컴포넌트를 사용하는 것을 허용하도록 리액트 훅 useState가 도입되었다. 

0부터 시작하여 버튼을 누르면 1 증가하는 간단한 카운터를 만들어보자

```jsx
const FunctionalComponent = () => {
	const [count, setCount] = React.useState(0);

	return (
		<div>
			<p>count : {count}</p>
			<button onClick={() => setCount(count + 1)}>Click</button>
		</div>
	);
}
```

함수형 컴포넌트에서 상태 변수를 사용하려면 초기 상태를 인자로 받는 useState 훅을 사용해야 한다.

물론 null, string, object를 포함해서 다양한 상태를 받을 수 있다.

useState는 현재 상태와 상태를 업데이트하는 함수를 반환한다. (state, setter)

```jsx
class ClassComponent extends React.Component {
	constructor(props) {
		super(props);
		this.state = {
			count: 0
		};
	}

	render() {
		<div>
			<p>count : {this.state.count} </p>
			<button onClick={() => this.setState({count: this.state.count + 1})}>
				Click
			</button>
		</div>
	};
}
```

클래스형 컴포넌트에서 React.Component의 constructor는 마운트 되기 전에 호출된다.

React.Component의 하위 클래스 생성자를 구현할 때, super(props)를 다른 구문보다 앞에 호출해야 한다. 그렇지 않으면 this.props는 생성자에서 undefined가 될 것이다.

근본적으로 생성자 구현과 super(props) 호출 없이 모든 상태 변수들은 undefined가 될 것이다.

그래서 먼저 생성자를 정의해야 한다. 생성자 내부에 state를 키로 하는 객체를 만들고 초기 값을 설정할 것이다.

**Lifecycle Methods**

생명주기는 렌더링 시기에 중요한 역할을 한다.

**on Mounting (componentDidMount)**

*마운트는 컴포넌트가 생성되고 DOM에 노드가 추가되어 브라우저에 나타나는 과정

componentDidMount 메소드는 첫 번째 렌더링이 완료된 직후 호출된다.

그 이전에는 componentWillMount가 첫 번째 렌더링 전에 발생했지만 레거시로 간주되어 최신 버전 리액트에서 사용하는 것을 권장하지 않는다.

componentDidMount() 를 대신해서 useEffect 훅을 사용한다.

useEffect의 두 번째 인자로 의존성 배열 [ ]을 갖는다. 의존성 배열에는 보통 변하는 상태들이 들어온다. useEffect는 의존성 배열에 있는 상태들이 변할 때만 호출된다.

의존성 배열이 비어 있다면, 마운팅 된 이후에 한 번만 호출된다.

```jsx
class ClassComponent extends React.Component {
	componentDidMount() {
		console.log("Hello");
	}

	render() {
		return <p>Hello, world</p>
	}
}
```

함수형 컴포넌트에서는 componentDidMount를 useEffect 훅으로 대신 할 수 있다.

```jsx
const FunctionalComponent = () => {
	React.useEffect(() => {
		console.log("Hello");
	}, []);
	return <p>Hello, world</p>
}
```

**on Updating (componentDidUpdate)**

리렌더링이 완료된 후 실행되는 메서드이다.

컴포넌트가 리렌더링 되고 DOM 조작하거나 이전과 현재 props를 비교하여 작업할 때 사용한다.

**on Unmounting (componentWillUnmount)**

언마운팅 할 때도 useEffect 훅을 사용할 수 있다. 하지만 구문이 살짝 다르다.

언마운팅 할 때, useEffect에서 함수를 리턴하면 언마운팅 할 때 해당 함수가 실행된다.

```jsx
class ClassComponent extends React.Component {
	componentWillUnmount() {
		console.log("Bye");
	}

	render() {
		return <p>Bye, world</p>;
	}
}
```

함수형 컴포넌트에서는 componentWillUnmount를 useEffect 훅으로 대신할 수 있다.

```jsx
const FunctionalComponent = () => {
	React.useEffect(()=>{
		return () => {
			console.log("Bye");
		};
	}, []);

	return <p>Bye, world</p>;
}
```

참고
https://www.twilio.com/blog/react-choose-functional-components

# TDD에 대해 설명해주세요.

Test Driven Development의 약자로 테스트 주도 개발이라 할 수 있다.

이는 테스트 케이스를 미리 작성하고 테스트 케이스가 잘 동작하는지 검증하기 위해 코드를 작성하는 개발 접근법이다.

TDD는 어플리케이션의 모든 작은 기능들을 위한 테스트를 설계하고 개발부터 시작한다.

TDD 프레임워크는 개발자에게 자동화 테스트가 실패된 경우에만 새 코드를 작성하도록 하기 때문에 중복 코드를 피할 수 있다.

**TDD 이점**

TDD는 Agile 개발에 적합하다.

Agile 개발은 정기적인 피드백을 요구하는데, 개발 스프린트 주기동안 프로젝트 요구사항이 바뀔 가능성이 있다. 이를 처리하고 변화된 요구사항에 맞춰 프로젝트를 만들기 위해선 불필요한 소프트웨어 버리는 것을 피하기 위해 지속적인 피드백이 필요하다. TDD는 그러한 피드백을 초기에 제공할 수 있다.

TDD는 프로젝트의 품질과 납기를 방해하는 중요한 병목현상을 완화시키는데 도움을 줄 수 있다. 지속적인 피드백, 버그 수정, 새 기능 추가에 기반하여 모든 것들이 의도한대로 동작하는 것을 보장하도록 프로젝트가 개발이 된다. 

TDD는 클라이언트 뿐만 아니라 개발, QA 팀간 협업을 강화한다.

게다가 테스트가 미리 만들어져 있어서 방대한 테스트 스크립트를 다시 만드는데 시간을 소비할 필요가 없다.

1. 최적화된 코드를 작성하는데 도움을 준다.
2. 클라이언트 요구 사항이 부적절하게 정의된 경우 개발자가 요구사항을 더 잘 이해하도록 도움을 준다.
3. 개발 후반에서 새로운 기능 추가 및 테스트가 쉽다.
4. TDD는 초기부터 각 기능의 테스트를 작성하는데 초점을 두기 때문에 기존 개발 모델에 비해 테스트 범위가 훨씬 넓다.
5. 개발자의 생산성을 높이고 유연하고 유지 보수하는데 쉬운 코드 개발로 이어진다.

Javascript TDD 프레임워크로는 FaceBook에 의해 만들어진 Jest가 있다.

참고
https://www.guru99.com/test-driven-development.html
https://www.browserstack.com/guide/what-is-test-driven-development